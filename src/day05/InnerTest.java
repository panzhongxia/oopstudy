package day05;

public class InnerTest {
    public static void main(String[] args){
        //实例化餐厅对象
        Kitchen k = new Kitchen("同福餐厅","郭芙蓉","李大嘴");
        //客人点菜：
        System.out.println(k.order("宫保鸡丁"));
        //结论：内部类一般不在外部类的外部实例化对象，内部类对象仅供外部类中使用，其他使用者，无需知道实现细节

        //匿名内部类的测试
        //为了保证运行时，动态选择厨师，做不同的菜，指向对象的变量，必须使用父类型
//        //需要一位川菜厨子
//        Cook cook = new SiChuan("川菜厨子");
//        cook.cook();
//        //又需要一位鲁菜厨子
//        cook = new ShanDong("鲁菜厨子");
//        cook.cook();
        //问题：无法确定运行时，厨师具体要做哪种菜，可能性非常多，无法尽数
        //解决：匿名内部类，一个具体的实现类都不定义，随用，随时定义
        //用法：使用父类型变量 实例化一个父类型对象
        //比如：需要做“醉虾”
        //    又需要做”辣子鸡“
//        Cook cook = new Cook("鲁菜师傅") {
        Cook cook = new Cook("川菜师傅") {
            //编译错误1：因为匿名内部类第一件事是实例化父类型对象，就必须调用父类型构造方法
            //编译错误2：因为匿名内部类第二件事是继承父类型，并实现父类型中的抽象方法
            @Override
            public void cook() {
                buy();
                //name属性继承自父类型
//                System.out.println(name+"做醉虾.....");
                System.out.println(name+"做辣子鸡.....");
            }
            //匿名内部类可以定义自己的方法
            public void buy() {
//                System.out.println("去市场买虾");
                System.out.println("去市场买鸡");
            }
        };//结尾必须分号结束
        //匿名内部类仅实例化一个对象
        //使用匿名内部类都要使用对象调用
        cook.cook();
        //结论：匿名内部类是一句话办三件事：
        //1.调用父类型构造方法实例化1个父类型的对象
        //2.因为父类型一般是接口或抽象类，不能直接实例化。其实，匿名内部类是继承父类型，实现父类型，并定义自己的实现
        //3.匿名内部类中也可以定义普通的方法定义，方法之间同样也可相互调用
        //优缺点：
        //优点：非常灵活，没有剧本，想怎么实现，就怎么实现
        //缺点：类的定义不可重用！不便于大项目的维护。

    }
}
